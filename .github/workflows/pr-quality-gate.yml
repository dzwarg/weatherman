name: PR Quality Gate

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main

# Ensure only one workflow runs per PR
concurrency:
  group: pr-quality-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  # T023: Branch name validation
  validate-branch-name:
    name: Validate Branch Name
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Check branch name format
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "Validating branch name: $BRANCH_NAME"

          # Branch must match: NNN-feature-description (speckit convention)
          # where NNN is a 3-digit spec number
          if [[ ! "$BRANCH_NAME" =~ ^[0-9]{3}-.+ ]]; then
            echo "::error::Branch name '$BRANCH_NAME' does not match required format"
            echo "::error::Expected format: NNN-feature-description"
            echo "::error::Example: 003-automated-build-test"
            exit 1
          fi

          echo "‚úÖ Branch name format is valid"

  # T024: Deployment status check
  check-deployment-status:
    name: Check Deployment Status
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Check for active deployments
        uses: actions/github-script@v7
        with:
          script: |
            const { data: deployments } = await github.rest.repos.listDeployments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              environment: 'production',
              per_page: 10
            });

            // Check for any in_progress deployments
            for (const deployment of deployments) {
              const { data: statuses } = await github.rest.repos.listDeploymentStatuses({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.id,
                per_page: 1
              });

              if (statuses.length > 0 && statuses[0].state === 'in_progress') {
                core.setFailed(`‚ùå Deployment #${deployment.id} is currently in progress. Please wait for it to complete before merging.`);
                return;
              }
            }

            console.log('‚úÖ No active deployments found');

  # T026: Conventional commit validation
  validate-commits:
    name: Validate Commit Messages
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check conventional commit format
        run: |
          echo "Checking commits in PR..."

          # Get all commits in the PR
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          COMMITS=$(git log --format="%H %s" $BASE_SHA..$HEAD_SHA)

          INVALID_COMMITS=0
          while IFS= read -r line; do
            COMMIT_SHA=$(echo "$line" | cut -d' ' -f1)
            COMMIT_MSG=$(echo "$line" | cut -d' ' -f2-)

            # Conventional commit format: type(scope?): description
            # Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert
            if [[ ! "$COMMIT_MSG" =~ ^(feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?\!?:\ .+ ]]; then
              echo "::error::Commit $COMMIT_SHA has invalid format: $COMMIT_MSG"
              echo "::error::Expected format: type(scope?): description"
              echo "::error::Types: feat, fix, docs, style, refactor, test, chore, perf, ci, build, revert"
              INVALID_COMMITS=$((INVALID_COMMITS + 1))
            fi
          done <<< "$COMMITS"

          if [ $INVALID_COMMITS -gt 0 ]; then
            echo "::error::Found $INVALID_COMMITS commit(s) with invalid conventional commit format"
            exit 1
          fi

          echo "‚úÖ All commits follow conventional commit format"

  # T027: GPG signature verification
  verify-signatures:
    name: Verify GPG Signatures
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check GPG signatures
        run: |
          echo "Checking GPG signatures for commits in PR..."

          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          HEAD_SHA="${{ github.event.pull_request.head.sha }}"

          UNSIGNED_COMMITS=0
          git log --format="%H %G? %GS" $BASE_SHA..$HEAD_SHA | while IFS= read -r line; do
            COMMIT_SHA=$(echo "$line" | awk '{print $1}')
            SIG_STATUS=$(echo "$line" | awk '{print $2}')
            SIGNER=$(echo "$line" | cut -d' ' -f3-)

            # G = good signature, U = good signature with unknown validity
            # B = bad signature, N = no signature
            if [[ "$SIG_STATUS" != "G" && "$SIG_STATUS" != "U" ]]; then
              echo "::warning::Commit $COMMIT_SHA is not signed or has invalid signature (status: $SIG_STATUS)"
              UNSIGNED_COMMITS=$((UNSIGNED_COMMITS + 1))
            else
              echo "‚úÖ Commit $COMMIT_SHA signed by: $SIGNER"
            fi
          done

          # Note: GitHub's web interface commits may not have GPG signatures
          # This is informational only and won't block the PR
          echo "GPG signature check complete"

  # T025: Run CI quality checks inline (artifacts must be in same workflow)
  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint

  test-frontend:
    name: Test Frontend
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      - run: npm ci
      - run: npm test --workspace=packages/frontend -- --run
      - name: Upload frontend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: frontend-coverage
          path: packages/frontend/coverage/
          retention-days: 90

  test-backend:
    name: Test Backend
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      - run: npm ci
      - run: npm test --workspace=packages/server -- --run
      - name: Upload backend coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: backend-coverage
          path: packages/server/coverage/
          retention-days: 90

  build:
    name: Build Packages
    runs-on: ubuntu-latest
    needs: [lint, test-frontend, test-backend]
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
      - run: npm ci
      - run: npm run build --workspace=packages/frontend

  # T028: Aggregate coverage calculation
  calculate-coverage:
    name: Calculate Coverage
    runs-on: ubuntu-latest
    needs: [test-frontend, test-backend]
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Download frontend coverage
        uses: actions/download-artifact@v4
        with:
          name: frontend-coverage
          path: coverage-frontend

      - name: Download backend coverage
        uses: actions/download-artifact@v4
        with:
          name: backend-coverage
          path: coverage-backend

      - name: Calculate aggregate coverage
        id: coverage
        run: |
          echo "Calculating aggregate coverage across packages..."

          # Extract coverage percentages from coverage-summary.json
          FRONTEND_COVERAGE=$(cat coverage-frontend/coverage-summary.json | jq '.total.statements.pct')
          BACKEND_COVERAGE=$(cat coverage-backend/coverage-summary.json | jq '.total.statements.pct')

          echo "Frontend coverage: ${FRONTEND_COVERAGE}%"
          echo "Backend coverage: ${BACKEND_COVERAGE}%"

          # Calculate weighted average (assuming equal weight)
          AGGREGATE_COVERAGE=$(echo "scale=2; ($FRONTEND_COVERAGE + $BACKEND_COVERAGE) / 2" | bc)
          echo "Aggregate coverage: ${AGGREGATE_COVERAGE}%"

          # Check 80% threshold
          THRESHOLD=80
          if (( $(echo "$AGGREGATE_COVERAGE < $THRESHOLD" | bc -l) )); then
            echo "::error::Aggregate coverage ${AGGREGATE_COVERAGE}% is below ${THRESHOLD}% threshold"
            exit 1
          fi

          echo "‚úÖ Aggregate coverage meets ${THRESHOLD}% threshold"

          # Export for PR comment
          echo "frontend_coverage=$FRONTEND_COVERAGE" >> $GITHUB_OUTPUT
          echo "backend_coverage=$BACKEND_COVERAGE" >> $GITHUB_OUTPUT
          echo "aggregate_coverage=$AGGREGATE_COVERAGE" >> $GITHUB_OUTPUT

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        with:
          name: aggregate-coverage
          path: |
            coverage-frontend/
            coverage-backend/

  # T029: Post coverage summary to PR
  comment-coverage:
    name: Post Coverage Comment
    runs-on: ubuntu-latest
    needs: calculate-coverage
    if: always()
    permissions:
      pull-requests: write
    steps:
      - name: Download coverage data
        uses: actions/download-artifact@v4
        with:
          name: aggregate-coverage
          path: coverage

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read coverage data
            const frontendSummary = JSON.parse(fs.readFileSync('coverage/coverage-frontend/coverage-summary.json', 'utf8'));
            const backendSummary = JSON.parse(fs.readFileSync('coverage/coverage-backend/coverage-summary.json', 'utf8'));

            const frontendPct = frontendSummary.total.statements.pct;
            const backendPct = backendSummary.total.statements.pct;
            const aggregatePct = ((frontendPct + backendPct) / 2).toFixed(2);

            // Create coverage table
            const table = `
            ## üìä Code Coverage Report

            | Package | Statements | Branches | Functions | Lines | Status |
            |---------|------------|----------|-----------|-------|--------|
            | **Frontend** | ${frontendPct}% | ${frontendSummary.total.branches.pct}% | ${frontendSummary.total.functions.pct}% | ${frontendSummary.total.lines.pct}% | ${frontendPct >= 80 ? '‚úÖ' : '‚ùå'} |
            | **Backend** | ${backendPct}% | ${backendSummary.total.branches.pct}% | ${backendSummary.total.functions.pct}% | ${backendSummary.total.lines.pct}% | ${backendPct >= 80 ? '‚úÖ' : '‚ùå'} |
            | **Aggregate** | **${aggregatePct}%** | - | - | - | ${aggregatePct >= 80 ? '‚úÖ PASS' : '‚ùå FAIL'} |

            **Threshold**: 80% minimum coverage required

            ${aggregatePct >= 80 ? '‚úÖ Coverage meets requirements' : '‚ùå Coverage below threshold - please add more tests'}
            `;

            // Find existing coverage comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const coverageComment = comments.find(comment =>
              comment.body.includes('üìä Code Coverage Report')
            );

            if (coverageComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: coverageComment.id,
                body: table
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: table
              });
            }

  # Summary job - all checks must pass
  quality-gate-summary:
    name: Quality Gate Summary
    runs-on: ubuntu-latest
    needs:
      - validate-branch-name
      - check-deployment-status
      - validate-commits
      - verify-signatures
      - lint
      - test-frontend
      - test-backend
      - build
      - calculate-coverage
    if: always()
    steps:
      - name: Check quality gate status
        run: |
          echo "Quality Gate Results:"
          echo "- Branch name validation: ${{ needs.validate-branch-name.result }}"
          echo "- Deployment status check: ${{ needs.check-deployment-status.result }}"
          echo "- Commit format validation: ${{ needs.validate-commits.result }}"
          echo "- GPG signature verification: ${{ needs.verify-signatures.result }}"
          echo "- Lint: ${{ needs.lint.result }}"
          echo "- Frontend tests: ${{ needs.test-frontend.result }}"
          echo "- Backend tests: ${{ needs.test-backend.result }}"
          echo "- Build: ${{ needs.build.result }}"
          echo "- Coverage calculation: ${{ needs.calculate-coverage.result }}"

          # Fail if any required check failed
          if [[ "${{ needs.validate-branch-name.result }}" != "success" ]] || \
             [[ "${{ needs.check-deployment-status.result }}" != "success" ]] || \
             [[ "${{ needs.validate-commits.result }}" != "success" ]] || \
             [[ "${{ needs.lint.result }}" != "success" ]] || \
             [[ "${{ needs.test-frontend.result }}" != "success" ]] || \
             [[ "${{ needs.test-backend.result }}" != "success" ]] || \
             [[ "${{ needs.build.result }}" != "success" ]] || \
             [[ "${{ needs.calculate-coverage.result }}" != "success" ]]; then
            echo "::error::‚ùå Quality gate FAILED - one or more required checks did not pass"
            exit 1
          fi

          echo "‚úÖ All quality gate checks PASSED"
